#notes #books #understandingDS #communincation


![](attachment/a7912d11e77ce5cc3c722a24c168095b.png)

The Internet Protocol suite, each layer builds on the abstraction provided by the layer below. This specifies how the data should be packetized, addressed, transmitted and routed and received


# Reliable Links


routing packer from one point to another

The addressing is handled by the IP protocol (IPv6 / IPv4)
The routing is decided by the Border Gateway Protocol -> [RFC](https://datatracker.ietf.org/doc/html/rfc4271)
The reliability is provided by the TCP ( transport layer) -> [RFC](https://datatracker.ietf.org/doc/html/rfc793)

Now TCP relies on  a connection to be established before it takes any decisions.
So a connection has multiple states represented by here -> [TCP State Diagram](https://en.wikipedia.org/wiki/Transmission_Control_Protocol#/media/File:Tcp_state_diagram_fixed_new.svg)

But ideally there are three major states
1. The opening state
2. The established state
3. The closing state

TCP also uses the flow control and congestion control mechanism

`Flow control`  is backoff mechanism , where the receiver stores the incoming messages in a receive buffer
The receiver send the size of the available bucket  to the send within the ack message. So the sender can determine whether or not send another message or not

`Congestion Control`, the sender maintains a congestion window, which tell the sender the number of messages that can be sent without an ack

Hence the smaller this window the smaller the utilization of the bandwidth. This window starting from a default value is increasing with successful received messages and reduced with the missed acks, also called the congestion avoidance
More reading - [Bandwidth Delay Product](https://en.wikipedia.org/wiki/Bandwidth-delay_product)

In place of TCP we can also use UDP -> [RFC](https://datatracker.ietf.org/doc/html/rfc768), which drops the stability or reliability for better latencies, this is particularly useful during streaming applications / multiplayer games.


# Secure Links

Now the transport layer also has to care for the security of the sent packets or the chunks, hence it  uses TLS -> [RFC](https://datatracker.ietf.org/doc/html/rfc8446) on top of the TCP 

TLS ensures the encryption / authentication / integrity

## Encryption

this is done by asymmetric encryption where the sender and the receiver at the time of establishing a connection negotiate a shared encryption secret (public / private keys)
Further Reading - [Elliptic Curve Cryptography](https://blog.cloudflare.com/a-relatively-easy-to-understand-primer-on-elliptic-curve-cryptography/)

## Authentication

the authentication of the source is done through digital signatures and certificates
the digital signatures or the public keys are authenticated by the certificates.
Further Reading - [Digital Signatures](https://en.wikipedia.org/wiki/Digital_signature)

These certificates are issued by a Certificate Authority ([Lets Encrypt](https://letsencrypt.org/)). This certificate usually contains information about the owning entity / expiration date / public key / digital signature of the party that issues the certificate

## Integrity

this is guaranteed by using the hash function with the transmitted packets or the chunks. The hash function creates a Message Authentication Code (HMAC) -> [RFC](https://datatracker.ietf.org/doc/html/rfc2104)
This protects against the data corruption / data tampering.
Although given this , its still not 100% reliable. It doesn't detect errors for roughly 1 in 16illion to 10 billion packets.
Further Reading - [Article](https://dl.acm.org/doi/10.1145/347057.347561)





So when establishing a secure connection there are multiple steps to be taken
1. Parties deciding on cipher suit eon which the secure channel is created
2. Key Exchange algo to generate the secrets
3. Signature Algorithm to sign the certificates
4. Encryption Algorithm to encrypt the data
5. HMAC algo to  hash and maintain the integrity of the data

Parties can use the shared secret to encrypt the information in the channel
and the client and server can verify the certificates if availableb